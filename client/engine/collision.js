// Class that detects collision between player and other objects
class Collision {

	constructor(scenarioWidth, scenarioHeight, player) {
		this.colItens = new Array(); // Items to check for collision
    this.scenarioWidth = scenarioWidth;
    this.scenarioHeight = scenarioHeight;
    this.player = player;
  }
			
  // # Check if the object collides with any object in vector
  // Algorithm reference: Gustavo Silveira - https://www.youtube.com/watch?v=s7qiWLBBpJw
  check(object) {
    for (let i in this.colItens) {
      let r1 = object;
      let r2 = this.colItens[i];
      this.checkCollision(r1, r2);
    } 
  }

  // @r1: the moving object
  // @r2: the "wall"
  checkCollision(r1, r2) {

    // Don't check collision between same object
    if( r1.name == r2.name ) return;
    
    // Only checks objects that needs to be checked
    if( ! r2.triggersCollisionEvent() && ! r2.stopIfCollision() ) return false;

    // stores the distance between the objects (must be rectangle)
    var catX = r1.getCenterX() - r2.getCenterX();
    var catY = r1.getCenterY() - r2.getCenterY();

    var sumHalfWidth = ( r1.getCollisionWidth() / 2 ) + ( r2.getCollisionWidth() / 2 );
    var sumHalfHeight = ( r1.getCollisionHeight() / 2 ) + ( r2.getCollisionHeight() / 2 ) ;
    
    if(Math.abs(catX) < sumHalfWidth && Math.abs(catY) < sumHalfHeight){
      
      var overlapX = sumHalfWidth - Math.abs(catX);
      var overlapY = sumHalfHeight - Math.abs(catY);

      if( r2.stopIfCollision() ) {
        if(overlapX >= overlapY ){ // Direction of collision - Up/Down
          if(catY > 0){ // Up
            // Only moves if it wont collide
            //if( !this.willCollideInFuture(r1, r1.getCollisionX(), r1.getCollisionY() + overlapY ) ) {
              r1.setY( r1.getY() + overlapY );
              r1.setCollisionY( r1.getCollisionY() + overlapY );
              if( r1.type == 'player' ) r1.updateGrabCollisionXY();
            //}
          } else {
            //if( !this.willCollideInFuture(r1, r1.getCollisionX(), r1.getCollisionY() - overlapY ) ) {
              r1.setY( r1.getY() - overlapY );
              r1.setCollisionY( r1.getCollisionY() - overlapY );
              if( r1.type == 'player' ) r1.updateGrabCollisionXY();
            //}
          }
        } else {// Direction of collision - Left/Right
          if(catX > 0){ // Left
            //if( !this.willCollideInFuture(r1, r1.getCollisionX() + overlapX, r1.getCollisionY() ) ) {
              r1.setX( r1.getX() + overlapX );
              r1.setCollisionX( r1.getCollisionX() + overlapX );
              if( r1.type == 'player' ) r1.updateGrabCollisionXY();
            //}
          } else {
            //if( !this.willCollideInFuture(r1, r1.getCollisionX() - overlapX, r1.getCollisionY() ) ) {
              r1.setX( r1.getX() - overlapX );
              r1.setCollisionX( r1.getCollisionX() - overlapX );
              if( r1.type == 'player' ) r1.updateGrabCollisionXY();
            //}
          }
        }
      }

      if( window.debugCollision ) {
        console.log('Collision between', r1.name + "(" + r1.getX() + "/" + r1.getY() + ")", r2.name);
      }

      // Triggers Collision event
      r1.collision(r2, r1);
      r2.collision(r1, r2);

    } else {
      // Triggers not in collision event
      r1.noCollision(r2, r2); 
      r2.noCollision(r1, r2); 
    }

  }

  // Just check for a specific collision and return the firt object collided
  justCheck(r1, _x, _y, _w, _h) {
    let _r = false;
    for (let i in this.colItens) {
      let r2 = this.colItens[i];
      _r = this.justCheckCollision(r1, r2, _x, _y, _w, _h);
      if( _r ) {

      }
    } 
    return _r;
  }

  justCheckCollision(r1, r2, _x, _y, _w, _h) {

    // Don't check collision between same object
    if( r1.name == r2.name ) return;
    
    // Only checks objects that needs to be checked
    if( ! r2.triggersCollisionEvent() && ! r2.stopIfCollision() ) return false;
 
    // stores the distance between the objects (must be rectangle)
    var catX = ( _x / 2 ) - r2.getCenterX();
    var catY = ( _y / 2 ) - r2.getCenterY();
 
    var sumHalfWidth = ( _w / 2 ) + ( r2.getCollisionWidth() / 2 );
    var sumHalfHeight = ( _h / 2 ) + ( r2.getCollisionHeight() / 2 ) ;
    //if( r2.name == "object_500x600" ) {
      //console.log( Math.abs(catX), sumHalfWidth, Math.abs(catY), sumHalfHeight);
    //}
    if(Math.abs(catX) < sumHalfWidth && Math.abs(catY) < sumHalfHeight){
      //if( window.debugCollision ) {
        console.log('Collision between', r1.name + "(" + r1.getX() + "/" + r1.getY() + ")", r2.name);
        console.log( Math.abs(catX), sumHalfWidth, Math.abs(catY), sumHalfHeight);
        console.log(_x, _y, _w, _h);
      //}
      return r2;
    } else {
      return false;  
    }

  }
  		
	// Add items to check for collision
	addItem(object) {
		this.colItens.push(object);
  };
  
  addArrayItem(object){
		for (let i in object){
      this.colItens.push(object[i]);
    }
  }
  
  clearArrayItems() {
    this.colItens = new Array();
  }

}// class

module.exports = Collision;
	